# Components

Components are classes declared to be a component by one of the following decorators:

- `@Component`
- `@Service`
- `@Repository`
- `@Controller`
- `@ControllerAdvice`

Lets create a `RabbitService`, that stores our rabbits for now and will be
injected into the `RabbitController`.

```ts
import { Service } from 'revane';
import { Rabbit } from './Rabbit';

@Service
export class RabbitService {
  private readonly rabbits: Rabbit[] = [];

  create (rabbit: Rabbit) {
    this.rabbits.push(rabbit);
  }

  findAll (): Rabbit[] {
    return this.rabbits;
  }
}
```

The `RabbitService` is a simple class decorated with the `@Service` decorator. The `@Service` decorator declares the class to be a component managed by Revane.

The `Rabbit` might look like this:

```ts
// Rabbit.ts
export class Rabbit {
  constructor (
    public id: string,
    public color: string
  ) {}
}
```

## Dependency injection

Revane is using the design pattern known as dependency injection.

To inject a dependency, for example the `RabbitService`, into another component
declare it as a constructor parameter. Revane will create a singleton instance
of the `RabbitService` and pass it to the `RabbitController`'s constructor.

```ts
constructor(private rabbitService: RabbitService) {}
```

There are two ways Revane can inject dependencies: By type and by id.

### By Type with @Type

*since `3.2.0`*

```ts
constructor(
  @Type(RabbitService) private rabbitService: RabbitService) {}
```
> [!NOTE]
> Interfaces are being erased by the typescript compiler and are not
> available during runtime.

### By Type - Decorator Metadata

*deprecated*

Revane can use decorator metadata generated by Typescript to inject beans.

### By Id

The id of a bean can be used for injection.

```ts
constructor(private rabbitService: RabbitService) {}
```

> [!NOTE]
> The id of a bean is the name of the bean with the first character being small.
> Example: `class RabbitServie {}` has the id `rabbitService`

## Scopes

A component has one the following scopes:

| Scope     | Decorator             | Description                                                                                             |
|-----------|-----------------------|---------------------------------------------------------------------------------------------------------|
| singleton | `@Scope('singleton')` | A single instance of the component is shared in the applicaton. The singleton scope is used by default. |
| prototype | `@Scope('prototype')` | A new instance of the component is created for each other component depending on it.                    |

## Conditional beans

There multiple decorators that allow to control the creation of beans by conditions:

### @Conditional(condition)

*since `3.1.0`*

...

### @ConditionalOnMissingBean('id')

*since `3.0.0`*

...

### @ConditionalOnProperty('a.configuration.property', true)

*since `3.1.0`*

...

### @ConditionalOnResource('./relative/path/to/file.json')

*since `3.1.0`*

...

## @Bean

An alternative way to declare a bean is using the `@Bean` decorator on a method in a component.

```ts
import { Component, Bean } from "revane"

@Component
class Example {
  @Bean
  public bean() {
    return new ExampleImpl()
  }
}
```
